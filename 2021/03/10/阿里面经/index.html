<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.curryhqy.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面经">
<meta property="og:type" content="article">
<meta property="og:title" content="阿里面经">
<meta property="og:url" content="www.curryhqy.cn/2021/03/10/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="curryhqyの的blog">
<meta property="og:description" content="面经">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%E9%98%88%E5%80%BC%253D%E5%AE%B9%E9%87%8F%5Ctimes%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90">
<meta property="article:published_time" content="2021-03-10T05:56:53.795Z">
<meta property="article:modified_time" content="2022-05-11T03:26:00.265Z">
<meta property="article:author" content="curryhqy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.zhihu.com/equation?tex=%E9%98%88%E5%80%BC%253D%E5%AE%B9%E9%87%8F%5Ctimes%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90">

<link rel="canonical" href="www.curryhqy.cn/2021/03/10/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>阿里面经 | curryhqyの的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">curryhqyの的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">混着混着日子就没了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="www.curryhqy.cn/2021/03/10/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="curryhqy">
      <meta itemprop="description" content="现在我混日子，将来日子混我">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="curryhqyの的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          阿里面经
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-10 13:56:53" itemprop="dateCreated datePublished" datetime="2021-03-10T13:56:53+08:00">2021-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 11:26:00" itemprop="dateModified" datetime="2022-05-11T11:26:00+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><a id="more"></a>

<h3 id="阿里面经"><a href="#阿里面经" class="headerlink" title="阿里面经"></a>阿里面经</h3><h4 id="Java线程的状态？"><a href="#Java线程的状态？" class="headerlink" title="Java线程的状态？"></a>Java线程的状态？</h4><p>在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。</p>
<ul>
<li><p>当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值。</p>
</li>
<li><p>当线程对象调用了start()方法后，就处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p>
</li>
<li><p>如果处于就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体，则该线程处于运行状态。</p>
</li>
</ul>
<ul>
<li>阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。<br>等待阻塞：执行o.wait()方法，JVM会把该线程放入等待队列<br>同步阻塞：线程在获取对象的同步锁的同时，若该同步锁被其他的线程占用，JVM会将其放入锁池lock pool中<br>其他阻塞：线程执行Thread.sleep或t, join()方法，或发出I/O请求，JVM就将其设为阻塞状态。</li>
<li>线程会以下面三种方式结束，结束后就是死亡状态。<ol>
<li>正常结束：run（）或者call（）方法执行完成。</li>
<li>异常结束：线程抛出一个未捕获的Exception或Error。</li>
<li>调用stop：直接调用该线程的stop（）方法，也会释放该线程持有的所有锁的对象。</li>
</ol>
</li>
</ul>
<h4 id="进程和线程的区别，进程间如何通讯，线程间如何通讯？"><a href="#进程和线程的区别，进程间如何通讯，线程间如何通讯？" class="headerlink" title="进程和线程的区别，进程间如何通讯，线程间如何通讯？"></a>进程和线程的区别，进程间如何通讯，线程间如何通讯？</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p>
<p>进程间通信：</p>
<pre><code>1. 共享内存：（最快）相对于其他几种方式，共享内存直接在进程的虚拟地址空间进行操作，不再通过执行进入内核的系统调用来传递彼此的数据
2. 信号，本质是计数器，用于对多进程共享数据对象的访问。用于多进程对共享数据对象的访问。在进程访问临界资源之前，需要测试信号量，如果为正数，则信号量-1并且进程可以进入临界区，若为非正数，则进程挂起放入等待队列，直至有进程退出临界区，释放资源并+1信号量，此时唤醒等待队列的进程。信号量本身就是临界资源，所以必须是原子操作。
3. 管道：单向，一端输入，另一端输出，先进先出FIFO。管道也是文件。管道大小4096字节。
4. 消息队列：消息队列是先进先出FIFO原则。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</code></pre><p>线程间通信：</p>
<p>方式一：volatile，大致意思就是多个线程同时监听一个变量，当这个变量发生变化的时候 ，线程能够感知并执行相应的业务。</p>
<p>方式二：<em>Object</em>类提供了线程间通信的方法：<em>wait()</em>、<em>notify()</em>、<em>notifyaAll()</em>，它们是多线程通信的基础，而这种实现方式的思想自然是线程间通信。wait和 notify必须配合synchronized使用，wait方法释放锁，notify方法不释放锁。</p>
<p>方式三：使用JUC工具类 CountDownLatch，基于AQS框架，相当于也是维护了一个线程间共享变量state。</p>
<p>（<strong>AQS框架</strong>：抽象的队列同步器，常用的有：ReentrantLock/Semaphore/CountDownLatch，它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列），定义了两种资源共享方式：Exclusive独占，每次只能允许一个节点获取到资源，每次释放资源之后也只会唤醒后驱节点，如 ReentrantLock；Share共享，每次可以允许多个节点按照顺序获取资源，每次释放头节点资源后可能会唤醒后驱的后驱，如Semaphore/CountDownLatch</p>
<p><strong>队列储存同步获取资源失败的线程 头结点持有锁 头结点释放锁之后会唤醒后面的节点</strong>：</p>
<p>节点有五种状态：</p>
<p>​            <code>0</code>：初始状态或者不代表任何意义时的取值。</p>
<p>    <code>SIGNAL(-1)</code>：这个状态一般由下一个节点来设置，代表的意思是<strong>当前节点在释放了资源后将后续节点的线程唤醒</strong>。(大白话就是后续节点拜托前方的大哥东西用完了叫他，他先去睡会儿)</p>
<p>    <code>CONDITION(-2)</code>：表示节点处于等待队列中，<strong>等待队列中的节点不会参与资源竞争</strong>，必须从等待队列出来后重新加入同步队列才能参与竞争。</p>
<p>    <code>PROPAGATE(-3)</code>：在<strong>共享模式</strong>的时候用到。共享模式下，<strong>不仅只是唤醒下个节点，还可能唤醒下下个节点</strong>(根据当前剩余资源<code>state</code>的值能否满足最近节点的需求决定)。</p>
<p>    <code>CANCELLED(1)</code>：表示该节点没用了，可能是等太久了，也可能是其他原因，总之就是废了，处于该状态的节点不会再改变，所以<code>AQS</code>中经常会判断节点状态是否大于<code>0</code>来检查节点是否还有用。</p>
<p><strong>CyclicBarrier、CountDownLatch、Semaphore</strong>：</p>
<ol>
<li><p>CountDownLatch 类位于 java.util.concurrent 包下，利用它可以实现类似计数器的功能，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒</p>
</li>
<li><p>CyclicBarrier字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后， CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本：</p>
<p>1.public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务；</p>
<p>2.public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。</p>
</li>
<li><p>Semaphore：信号量，可以同时控制访问线程的个数，通过acquire（）获得许可，release（）释放一个许可。</p>
</li>
<li><p>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限</p>
</li>
</ol>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>比较并交换，它包含 3 个参数，CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作 。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p>
<p><strong>如何避免ABA</strong>：</p>
<p>部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p>
<h4 id="HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别"><a href="#HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别" class="headerlink" title="HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别"></a>HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别</h4><ul>
<li><p>Java有List，Set，Map等集合类；<br>List类型：List是有序的Collection，有ArrayList，Vector，LinkedList。</p>
<ul>
<li>ArrayList，内部通过数组实现，允许对元素进行快速的访问；（但是当数组大小不满足时需要增加存储能力，就要将已有数组的数据复制到新的存储空间中）适合随机查找和遍历，不适合插入和删除。</li>
<li>Vector，支持线程同步，某一时刻只有一个线程能写Vector，由于实现同步的高花费，因此访问速度比Array list慢。</li>
<li>LinkedList，用链表存储数据，适合动态地插入和删除，随机访问和遍历速度较慢。</li>
</ul>
<p>HashSet：哈希表里面存放的是哈希值，HashSet存储元素的顺序并不是按照存入时的顺序，而是按照哈希值来存数据，取数据也是按照哈希值取得的。元素的哈希值是通过元素的hashcode方法来获取的。<em>HashSet首先判断两个元素的哈希值，如果哈希值一样，接着就会比较equals方法，如果equals结果为true，就视为同一个元素。</em></p>
</li>
<li><p>HashMap 根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，具有很快的访问速度，但是遍历的顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。 如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使HashMap 具有线程安全的能力 或者使用 ConcurrentHashMap 。</p>
<p>![image-20210228164402484](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210228164402484.png)</p>
<p>![image-20210228163815581](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210228163815581.png)</p>
<p>数组 + 链表 +（链表元素超过8、总节点数超过64就会转化为红黑树） <strong>红黑树（将时间复杂度从链表长度On降为OlogN）</strong></p>
</li>
<li><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p>
</li>
<li><p>hashmap扩容机制：</p>
<ol>
<li><p>空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。</p>
</li>
<li><p>有参构造函数：用于指定容量。会根据指定的正整数找到<strong>不小于指定容量的2的幂数</strong>，将这个数设置赋值给<strong>阈值</strong>（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 <img src="https://www.zhihu.com/equation?tex=%E9%98%88%E5%80%BC%3D%E5%AE%B9%E9%87%8F%5Ctimes%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90" alt="[公式]"> 。（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）</p>
<p>对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>
</li>
<li><p>如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。<em>（容量和阈值都变为原来的2倍时，负载因子还是不变）</em></p>
</li>
</ol>
<p>![image-20210228170514644](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210228170514644.png)</p>
<p>![image-20210228170627854](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210228170627854.png)</p>
<p>ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全。</p>
</li>
<li><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。</p>
</li>
<li><p>HashMap为什么不是线程安全？</p>
<p>HashMap底层是一个<strong>Entry数组</strong>，当发生hash冲突的时候，hashmap是采用链表的方式来解决的，在对应的数组位置存放链表的头结点。对链表而言，<strong>新加入的节点会从头结点加入</strong>。</p>
<p>当<strong>多个线程同时操作同一个数组位置</strong>的时候，也都会先取得现在状态下该位置存储的头结点，然后各自去进行计算操作，之后再把结果写会到该数组位置去，其实写回的时候可能其他的线程已经就把这个位置给修改过了，就会<strong>覆盖其他线程的修改</strong>。</p>
</li>
</ul>
<p>![image-20210305001715627](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210305001715627.png)</p>
<p><strong>扩容机制详解：</strong></p>
<p>当往hashMap中成功插入一个key/value节点时，有可能触发扩容动作：<br>1、如果新增节点之后，所在链表的元素个数达到了阈值 <strong>8</strong>，则会调用<code>treeifyBin</code>方法把链表转换成红黑树，不过在结构转换之前，会对数组长度进行判断：</p>
<ul>
<li>如果数组长度n小于阈值<code>MIN_TREEIFY_CAPACITY</code>，默认是64，则会调用<code>tryPresize</code>方法把数组长度扩大到原来的两倍，并触发<code>transfer</code>方法，重新调整节点的位置。</li>
<li>新增节点之后，会调用<code>addCount</code>方法记录元素个数，并检查是否需要进行扩容，当数组元素个数达到阈值时，会触发<code>transfer</code>方法，重新调整节点的位置。</li>
</ul>
<p><strong>put详解：</strong></p>
<p>1.从底层数组取值，算出数组位置，如果该位置为空，直接把node插进去<br>2.如果该位置不为空，判断key是否重复了，如果重复，就替换掉老的node<br>3.如果该位置既不是空，又没重复，判断一下是否是红黑树<br>4.如果该位置既不是空，又没重复，又不是红黑树，那必然是链表。把node放下一链上。再看一下链表长度是否大于8 ，如果大于8，转成红黑树。4下面的和2一样。在链表上判断是否重复了，重复的话就把该位置的链表值替换掉<br>5.如果e不为空，执行替换操作 </p>
<p><strong>HashMap的长度为什么要是2的n次方？</strong></p>
<p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，hash%length==hash&amp;(length-1)的前提是length是2的n次方；</p>
<p>红黑树是一种自平衡二叉查找树，它可以在O(log n)，时间内做查找，插入和删除</p>
<p>性质1. 结点是红色或黑色。 </p>
<p>性质2. 根结点是黑色。 </p>
<p>性质3. 所有叶子都是黑色。（叶子是NIL结点） </p>
<p>性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）</p>
<p>性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。 </p>
<p><strong>红黑树与AVL树比较？？？</strong></p>
<p>删除节点导致失衡，AVL需要维护从被删除节点到根节点root这条路径上所有节点的平衡，旋转的量级为O(logN)，而RB-Tree最多只需要旋转3次实现复衡，只需O(1)，所以说RB-Tree删除节点的rebalance的效率更高，开销更小！</p>
<p>AVL的结构相较于RB-Tree更为平衡，插入和删除引起失衡，RB-Tree复衡效率更高；当然，由于AVL高度平衡，因此AVL的Search效率更高啦。</p>
<p>实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h4 id="CAS-Synchronized取代Segment-ReentrantLock"><a href="#CAS-Synchronized取代Segment-ReentrantLock" class="headerlink" title="CAS+Synchronized取代Segment+ReentrantLock"></a>CAS+Synchronized取代Segment+ReentrantLock</h4><p>以前：首先在初始化ConcurrentHashMap的时候,会初始化一个Segment数组,容量为16,而每个Segment呢,都继承了ReentrantLock类,也就是说每个Segment类本身就是一个锁,之后Segment内部又有一个table数组,而每个table数组里的索引数据呢,又对应着一个Node链表.首先,当我们使用put方法的时候,是对我们的key进行hash拿到一个整型,然后将整型对16取模,拿到对应的Segment,之后调用Segment的put方法,然后上锁,请注意,这里lock()的时候其实是this.lock(),也就是说,每个Segment的锁是分开的，其中一个上锁不会影响另一个,此时也就代表了我可以有十六个线程进来,而ReentrantLock上锁的时候如果只有一个线程进来,是不会有线程挂起的操作的,也就是说只需要在AQS里使用CAS改变一个state的值为1,此时就能对代码进行操作,这样一来,我们等于将并发量16了.</p>
<p>现在：Synchronized是靠对象的对象头和此对象对应的monitor来保证上锁的,也就是对象头里的重量级锁标志指向了monitor,而monitor呢,内部则保存了一个当前线程,也就是抢到了锁的线程.它是对Node链表里的每一个Node加锁,也就是说,Synchronized是将每一个Node对象作为了一个锁,这样做的好处是什么呢?将锁细化了,也就是说,除非两个线程同时操作一个Node,注意,是一个Node而不是一个Node链表,那么才会争抢同一把锁.</p>
<p>如果使用ReentrantLock其实也可以将锁细化成这样的,只要让Node类继承ReentrantLock就行了,这样的话调用f.lock()就能做到和Synchronized(f)同样的效果,但为什么不这样做呢?</p>
<p>锁已经被细化到这种程度了,那么出现并发争抢的可能性还高吗?还有就是,哪怕出现争抢了,只要线程可以在30到50次自旋里拿到锁,那么Synchronized就不会升级为重量级锁,而等待的线程也就不用被挂起,我们也就少了挂起和唤醒这个上下文切换的过程开销.但如果是ReentrantLock呢?它则只有在线程没有抢到锁,然后新建Node节点后再尝试一次而已,不会自旋,而是直接被挂起,这样一来,我们就很容易会多出线程上下文开销的代价。</p>
<p>Synchronized和ReentrantLock他们的开销差距是在释放锁时唤醒线程的数量,Synchronized是唤醒锁池里所有的线程+刚好来访问的线程,而ReentrantLock则是当前线程后进来的第一个线程+刚好来访问的线程.</p>
<h4 id="Cookie和Session的区别"><a href="#Cookie和Session的区别" class="headerlink" title="Cookie和Session的区别"></a>Cookie和Session的区别</h4><p>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据， 因此在考虑数据复杂性时首选 Session；</p>
<p> Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</p>
<ol>
<li><p>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</p>
</li>
<li><p>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</p>
</li>
<li><p>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</p>
</li>
</ol>
<h4 id="索引有什么用？如何建索引？"><a href="#索引有什么用？如何建索引？" class="headerlink" title="索引有什么用？如何建索引？"></a>索引有什么用？如何建索引？</h4><p>索引在MySQL中也叫做“键”，它是一个特殊的文件，它保存着数据表里所有记录的位置信息，更通俗的来说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。当数据库中数据量很大时，查找数据会变得很慢，我们就可以通过索引来提高数据库的查询效率。</p>
<p>不是索引越多越好，而是需要自己合理的使用。<br>对经常更新的表就避免对其进行过多索引的创建，对经常用于查询的字段应该创建索引，<br>数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历<br>索引的时间还要短，索引就可能不会产生优化效果。<br>在一字段上相同值比较多不要建立索引，比如在学生表的”性别”字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。</p>
<p>索引和主键：</p>
<p><strong>1.</strong> <strong>主键一定是唯一性索引，唯一性索引并不一定就是主键。</strong> </p>
<p><strong>2. 一个表中可以有多个唯一性索引，但只能有一个主键。</strong></p>
<p><strong>3. 主键列不允许空值，而唯一性索引列允许空值。</strong> </p>
<h4 id="ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。"><a href="#ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。" class="headerlink" title="ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。"></a>ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。</h4><p>ArrayList通过数组实现，只要size &gt; 数组的长度，就会触发grow，其中增长比例是原来的容量的一半；读取性能很高，随机访问时间复杂度为O(1)，适用于读大于写的场景。</p>
<p>LinkedList是是通过双向队列来实现的，更新效率更高，写只需要修改前后两个节点的相关引用，但是读取效率比较低，需要最多遍历一半长度的队列，适用与写大于读的场景。</p>
<p>关于remove：迭代器的remove方法与集合的remove方法,最大的不同是,迭代器的remove方法中包括对游标和expectedModCount的修正。<br>因为Iterator是在一个独立的线程中工作的,它在new Itr()进行初始化时,会记录当时集合中的元素,可以理解为记录了集合的状态,在使用集合的Remove方法对集合进行修改时,被记录的集合状态并不会与之同步改变,所以在cursor指向下一个要返回的元素时,可能会发生找不到的错误,即抛出ConcurrentModificationException异常。</p>
<h4 id="equals方法实现"><a href="#equals方法实现" class="headerlink" title="equals方法实现"></a>equals方法实现</h4><p>equal比较的是对象的地址，==比较的两个对象的引用（若为基本类型，则比较值）</p>
<p>如果没有重写hashCode()，则任何对象的hashCode（）值都不相等（而hashmap想让部分值的hashCode值一样，所以就要重写）；</p>
<p>HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。<br>如果只重写equals没有重写hashCode()，就会导致相同的key值也被hashcode认为是不同的key值（因为没有重写hashCode()，则任何对象的hashCode（）值都不相等），就会在hashmap中存储相同的key值（map中key值不能相同），这就不符合条件了。</p>
<p>equals和hashcode的关系:<br>1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；<br>2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)</p>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</p>
<p>面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</p>
<p>1、封装<br>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。<br>2、继承<br>提高代码复用性；继承是多态的前提。<br>3、多态<br>父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。</p>
<p>1、单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。<br>2、开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。<br>3、里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~<br>4、依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的是抽象的中国人，而不是你是xx村的。<br>5、接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</p>
<h4 id="VM如何加载字节码文件"><a href="#VM如何加载字节码文件" class="headerlink" title="VM如何加载字节码文件"></a>VM如何加载字节码文件</h4><p>java文件经过编译后得到class文件，被称为字节码文件，Class文件是一组以8字节为基础单位的二进制流，各个数据项目按照严格的顺序排列在class文件中，中间没有任何的分隔符，这使得class文件在存储的内容全部是虚拟机运行程序所必须的，当存储的数据大于8位就采用大端模式。class文件不想xml等语言有分隔符，所以各种数据类型的排列顺序还是数量都是严格的。</p>
<p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。</p>
<ol>
<li>在装载阶段，虚拟机需要完成以下3件事情</li>
</ol>
<p>​    (1) 通过一个类的全限定名来获取定义此类的二进制字节流</p>
<p>​    (2) 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>​    (3) 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。</p>
<ol start="2">
<li>如果我们是从自己本地的class文件加载类信息肯定不会出错，但是我们上面讲到了类的加载只是加载了一系列的二级制字节码，无法保证字节码的正确性，所以需要验证（通过网络下载.class文件；从zip，jar等归档文件中加载.class文件；从专有数据库中提取.class文件）</li>
<li>准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配（因为这里的变量都是类变量，实例变量在堆，类变量在方法区）</li>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行</li>
<li>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备阶段变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源。</li>
</ol>
<h4 id="如何排查内存溢出"><a href="#如何排查内存溢出" class="headerlink" title="如何排查内存溢出"></a>如何排查内存溢出</h4><ol>
<li><strong><code>使用jdk自带的jvisualvm.exe，查看占空间的类和实例最多的类，找到其最近的内存释放点一般就是内存泄漏的对象。</code></strong></li>
<li><strong>也可以使用jmap查看jvm进程实例最多的类。</strong></li>
</ol>
<h4 id="ThreadLocal？"><a href="#ThreadLocal？" class="headerlink" title="ThreadLocal？"></a>ThreadLocal？</h4><p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
<p><strong>与同步方式比较</strong>：概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h4 id="IO与NIO？"><a href="#IO与NIO？" class="headerlink" title="IO与NIO？"></a>IO与NIO？</h4><ol>
<li>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li>
<li>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。  NIO通讯是将整个任务切换成许多小任务，由一个线程负责处理所有io事件，并负责分发。它是利用<strong>事件驱动机制</strong>，而不是监听机制，事件到的时候再触发。NIO线程之间通过wait，notify等方式通讯。保证了每次上下文切换都有意义，减少无谓的进程切换。<strong>本质上是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写</strong></li>
<li>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</li>
<li>BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</li>
<li>AIO：异步非阻塞，在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。</li>
<li><strong>零拷贝</strong>：传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。<br>零拷贝主要的任务就是<strong>避免</strong>CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。调用sendfile</li>
</ol>
<h4 id="mysql存储引擎-myIsam和innodb的区别？"><a href="#mysql存储引擎-myIsam和innodb的区别？" class="headerlink" title="mysql存储引擎 myIsam和innodb的区别？"></a><strong>mysql存储引擎 myIsam和innodb的区别</strong>？</h4><p><strong>MyISAM类型（表级锁）不支持事务处理等高级处理，而InnoDB（行级锁）类型支持。MyISAM类型表强调性能，其执行速度比InnoDB快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</strong></p>
<ol>
<li><p>InnoDB中不保存表的具体行数，也就是说当执行select count(<em>) from table时，InnoDB会扫描一遍整张表来计算有多少行，但是MyISAM只需要简单地读出保存好的行数即可。需要注意的是count(</em>)语句中包含where条件时两种表的操作是一致的。</p>
</li>
<li><p>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，而在MyISAM中可以和其他字段一起建立联合索引。</p>
</li>
<li><p>InnoDB表的行锁也不是绝对的，假如在执行一个SQL语句时MySQL不能确定要扫描的范围，此时InnoDB依旧会锁全表，例如update table set num=1 where name like ‘%aaa%’。</p>
</li>
<li><h3 id="两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁："><a href="#两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁：" class="headerlink" title="两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁："></a>两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁：</h3><ol>
<li>平台上大多承载的是读多写少的项目，而MyISAM的读性能比InnoDB要强不少；</li>
<li>MyISAM的索引和数据是分开的，并且索引是有压缩的，这样内存使用率就提高了不少</li>
<li>使用事务的项目一般就用InnoDB。大项目总量约几个亿的rows的某一类型（如日志等）业务表会使用MyISAM。</li>
</ol>
</li>
<li><p>清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p>
</li>
<li><p><strong>聚簇索引innodb与非聚簇索引MyISAM？</strong></p>
<p><strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</p>
<p><strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置</p>
<p><strong>在innodb中</strong>，在聚簇索引之上创建的索引称之为辅助索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。<strong>辅助索引叶子节点存储的不再是行的物理位置，而是主键值，辅助索引访问数据总是需要二次查找</strong>。</p>
<p><strong>MyISAM使用的是非聚簇索引</strong>，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
</li>
</ol>
<h4 id="缓存失效如何解决？"><a href="#缓存失效如何解决？" class="headerlink" title="缓存失效如何解决？"></a>缓存失效如何解决？</h4><p>引起这个原因的主要因素是高并发下，我们一般设定一个缓存的过期时间时，可能有一些会设置5分钟啊，10分钟这些；并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间在同一时刻，这个时候就可能引发——当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p>
<p>处理方法：</p>
<p>一个简单方案就是将缓存失效时间分散开，不要所以缓存时间长度都设置成5分钟或者10分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<p><strong>缓存穿透</strong>：</p>
<p>　　出现场景：指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>　　当在流量较大时，出现这样的情况，一直请求DB，很容易导致服务挂掉。</p>
<p>处理方法：</p>
<p>　　　　方法1.在封装的缓存SET和GET部分增加个步骤，如果查询一个KEY不存在，就已这个KEY为前缀设定一个标识KEY；以后再查询该KEY的时候，先查询标识KEY，如果标识KEY存在，就返回一个协定好的非false或者NULL值，然后APP做相应的处理，这样缓存层就不会被穿透。当然这个验证KEY的失效时间不能太长。</p>
<p>　　　　方法2.如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</p>
<p>　　　　方法3.采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数<ol start="2">
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0<ol start="3">
<li>某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1<ol start="4">
<li>判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>优点：</p>
<p>不需要存储key，节省空间</p>
<p>缺点：</p>
<ol>
<li>算法判断key在集合中时，有一定的概率key其实不在集合中</li>
<li>无法删除</li>
</ol>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>
    </div>

    
    
    

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/25/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" rel="prev" title="面试准备">
      <i class="fa fa-chevron-left"></i> 面试准备
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/04/06/%E9%9D%A2%E7%BB%8F1.0/" rel="next" title="面经1.0">
      面经1.0 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面经"><span class="nav-number">1.</span> <span class="nav-text">面经</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#阿里面经"><span class="nav-number">1.1.</span> <span class="nav-text">阿里面经</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程的状态？"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java线程的状态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程和线程的区别，进程间如何通讯，线程间如何通讯？"><span class="nav-number">1.1.2.</span> <span class="nav-text">进程和线程的区别，进程间如何通讯，线程间如何通讯？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS"><span class="nav-number">1.1.3.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别"><span class="nav-number">1.1.4.</span> <span class="nav-text">HashMap的数据结构是什么？如何实现的。和HashTable，ConcurrentHashMap的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-Synchronized取代Segment-ReentrantLock"><span class="nav-number">1.1.5.</span> <span class="nav-text">CAS+Synchronized取代Segment+ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cookie和Session的区别"><span class="nav-number">1.1.6.</span> <span class="nav-text">Cookie和Session的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引有什么用？如何建索引？"><span class="nav-number">1.1.7.</span> <span class="nav-text">索引有什么用？如何建索引？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。"><span class="nav-number">1.1.8.</span> <span class="nav-text">ArrayList是如何实现的，ArrayList和LinkedList的区别？ArrayList如何实现扩容。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals方法实现"><span class="nav-number">1.1.9.</span> <span class="nav-text">equals方法实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象"><span class="nav-number">1.1.10.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VM如何加载字节码文件"><span class="nav-number">1.1.11.</span> <span class="nav-text">VM如何加载字节码文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何排查内存溢出"><span class="nav-number">1.1.12.</span> <span class="nav-text">如何排查内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal？"><span class="nav-number">1.1.13.</span> <span class="nav-text">ThreadLocal？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO与NIO？"><span class="nav-number">1.1.14.</span> <span class="nav-text">IO与NIO？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql存储引擎-myIsam和innodb的区别？"><span class="nav-number">1.1.15.</span> <span class="nav-text">mysql存储引擎 myIsam和innodb的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁："><span class="nav-number">1.2.</span> <span class="nav-text">两种类型最主要的差别是InnoDB支持事务处理与外键和行级锁：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存失效如何解决？"><span class="nav-number">1.2.1.</span> <span class="nav-text">缓存失效如何解决？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#"><span class="nav-number">1.2.2.</span> <span class="nav-text"></span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">curryhqy</p>
  <div class="site-description" itemprop="description">现在我混日子，将来日子混我</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">curryhqy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
