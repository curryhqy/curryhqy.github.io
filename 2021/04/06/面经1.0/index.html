<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.curryhqy.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="面经">
<meta property="og:type" content="article">
<meta property="og:title" content="面经1.0">
<meta property="og:url" content="www.curryhqy.cn/2021/04/06/%E9%9D%A2%E7%BB%8F1.0/index.html">
<meta property="og:site_name" content="curryhqyの的blog">
<meta property="og:description" content="面经">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-04-06T02:12:54.770Z">
<meta property="article:modified_time" content="2022-05-11T03:22:16.573Z">
<meta property="article:author" content="curryhqy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="www.curryhqy.cn/2021/04/06/%E9%9D%A2%E7%BB%8F1.0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面经1.0 | curryhqyの的blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">curryhqyの的blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">混着混着日子就没了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="www.curryhqy.cn/2021/04/06/%E9%9D%A2%E7%BB%8F1.0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="curryhqy">
      <meta itemprop="description" content="现在我混日子，将来日子混我">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="curryhqyの的blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面经1.0
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-06 10:12:54" itemprop="dateCreated datePublished" datetime="2021-04-06T10:12:54+08:00">2021-04-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-11 11:22:16" itemprop="dateModified" datetime="2022-05-11T11:22:16+08:00">2022-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E7%BB%8F/" itemprop="url" rel="index"><span itemprop="name">面经</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><a id="more"></a>
<h3 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h3><p>Top K是很常见的一种问题，是指在N个数的无序序列中找出最大的K个数，而其中的N往往都特别大，对于这种问题，最容易想到的办法当然就是先对其进行排序，然后直接取出最大的K的元素就行了，但是这种方法往往是不可靠的，不仅时间效率低而且空间开销大，排序是对所有数都要进行排序，而实际上，这类问题只关心最大的K个数，并不关心序列是否有序，因此，排序实际上是浪费了的很多资源都是没必要的</p>
<h4 id="类选择排序"><a href="#类选择排序" class="headerlink" title="类选择排序"></a>类选择排序</h4><p>​    对目标序列N个数遍历，取出其中最大的数最为Top1；再次遍历剩下的N-1个数，取出其中最大的数为Top2；….再对剩下的N-K+1个数遍历，取出其中最大的数为TopK，这样就可以找到最大的K个数了。</p>
<p>​    时间复杂度方面，要求TopK就需要进行K次遍历，然后取出其中最大的数，因此算法平均时间复杂度为O(N*K);空间复杂度方面，可以看到这种方法需要开辟一个辅助空间来对取出过的元素进行标记，因此空间复杂度为O(N)，除此之外，还需注意到的是，这种方法有效的前提是提前将所有数读入，这样如果一开始的N较大，那么空间开销不可忽视。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>​    在快速排序中，每一轮排序都会将序列一分为二，左子区间的数都小于基准数，右子区间的数都大于基准数，而快速排序用来解决TopK问题，也是基于此的。N个数经过一轮快速排序后，如果基准数的位置被换到了i，那么区间[0,N-1]就被分为了[0,i-1]和[i+1,N-1]，这也就是说，此时有N-1-i个数比基准数大，i个数比基准数小，假设N-1-i=X那么就会有以下几种情况：</p>
<pre><code>1. X=K。这种情况说明比基准数大的有K个，其他的都比基准数小，那么就说明这K个比基准数大的数就是TopK了；
2. X&lt;K。这种情况说明比基准数大的数不到K个，但是这X肯定是属于TopK中的TopX，而剩下的K-X就在[0,i]之间，此时就应当在[0,i]中找到Top(K-X)，这就转换为了TopK的子问题，可以选择用递归解决；
3. X&gt;K。这种情况说明比基准数大的数超过了K个，那么就说明TopK必定位于[i+1,N-1]中，此时就应当继续在[i+1,N-1]找TopK，这样又成了TopK的一个子问题，也可以选择用递归解决。</code></pre><p>这种方法是利用了快速排序中找分割点的方法，每次分割后的数组大小近似为原数组大小的一半，因此这种方法的时间复杂度实际上O(NlogN)，时间复杂度虽然低，但是这种方法也需要提前将N个数读入，空间开销是一笔负担。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>在该方法中，首先需要对K个元素进行建堆，时间复杂度为O(K);然后对剩下的N-K个数对堆顶进行比较及更新，最好情况下当然是都不需要调整了，那么时间复杂度就只是遍历这N-K个数的O(N-K)，这样总体的时间复杂度就是O(N)，而在最坏情况下，N-K个数都需要更新堆顶，每次调整堆的时间复杂度为logK，因此此时时间复杂度就是NlogK了，总的时间复杂度就是O(K)+O(NlogK)≈O(NlogK)。空间复杂度是O(1)。（<strong>小根堆</strong>）</p>
<h3 id="HTTP1-0和HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-0和HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.0和HTTP1.1和HTTP2.0的区别"></a>HTTP1.0和HTTP1.1和HTTP2.0的区别</h3><h4 id="HTTP1-0和HTTP1-1的区别"><a href="#HTTP1-0和HTTP1-1的区别" class="headerlink" title="HTTP1.0和HTTP1.1的区别"></a>HTTP1.0和HTTP1.1的区别</h4><ol>
<li><p>长连接<br>在HTTP1.1中默认开启长连接keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接。</p>
</li>
<li><p>节约带宽<br>HTTP1.0中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。</p>
</li>
<li><p>HOST域<br>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname），HTTP1.0没有host域。随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。</p>
</li>
<li><p>缓存处理</p>
<p>在HTTP/1.0协议中，<strong>Last-Modified</strong>是控制缓存的一个非常重要的HTTP头。如果需要控制浏览器的缓存，服务器首先必须发送一个 以UTC时间为值的Last-Modifeid头，当第二次访问这个页面时，浏览器会发送一个If-Modified-Since头给服务器，让服务器判断是否有必要更新内容，这个If-Modified-Since头的值就是上次访问页面时浏览器发送的Last-Modifeid头的值。<strong>Expires</strong>是HTTP/1.0中另外一个很重要的HTTP头，它表示缓存的存在时间，告诉客户端浏览器在这个时间之前不对服务器发送请求，而直接使用浏览器的缓存。在HTTP/1.0中，可以使用Pragma: no-cache头来告诉浏览器不要缓存内容，它相当于HTTP/1.1中的Cache-Control:no-cache。</p>
<p>HTTP/1.0协议的这种实现方式的缺点是，服务器和客户端的时间有可能是不同步的，这样会造成缓存的实现达不到预期效果。HTTP/1.1协议用<strong>Cache-Control</strong>头解决了这个问题。</p>
<p>Cache-Control响应头的语法为：<br>Cache-Control = “Cache-Control” “:”; #缓存响应指令</p>
<p>缓存响应指令为一下几个中的任意一个：</p>
<ul>
<li>public 指示响应数据可以被任何客户端缓存</li>
<li>private 指示响应数据可以被非共享缓存所缓存。这表明响应的数据可以被发送请求的浏览器缓存，而不能被中介所缓存</li>
<li>no-cache 指示响应数据不能被任何接受响应的客户端所缓存</li>
<li>no-store 指示所传送的响应数据除了不能被缓存，也不能存入磁盘。一般用于敏感数据，以免数据被复制。</li>
<li>must-revalidate 指示所有的缓存都必须重新验证，在这个过程中，浏览器会发送一个If-Modified-Since头。如果服务器程序验证得出当前的响应数据为最新的 据，那么服务器应当返回一个304 Not Modified响应给客户端，否则响应数据将再次被发送到客户端。</li>
<li>proxy-revalidate 与must-revalidate相似，不同的是用来指示共享缓存。</li>
<li>max-age 数据经过max-age设置的秒数后就会失效，相当于HTTP/1.0中的Expires头。如果在一次响应中同时设置了max-age和Expires，那么max-age将具有较高的优先级。</li>
<li>s-maxage 与max-age相似，不同的是用来指示共享缓存。</li>
</ul>
</li>
<li><p>错误通知的管理<br>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
</li>
</ol>
<h4 id="HTTP1-1和HTTP2-0的区别"><a href="#HTTP1-1和HTTP2-0的区别" class="headerlink" title="HTTP1.1和HTTP2.0的区别"></a>HTTP1.1和HTTP2.0的区别</h4><ol>
<li><p>多路复用<br>HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
</li>
<li><p>头部数据压缩<br>在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过gzip压缩，或者本身传输的就是压缩过后的二进制文件，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着Web功能越来越复杂，每个页面产生的请求数也越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输UserAgent、Cookie这类不会频繁变动的内容，完全是一种浪费。</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
</li>
<li><p>服务器推送服务端推送是一种在客户端请求之前发送数据的机制。网页使用了许多资源：HTML、样式表、脚本、图片等等。在HTTP1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程。浏览器从获取HTML开始，然后在它解析和评估页面的时候，增量地获取更多的资源。因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。<br>为了改善延迟，HTTP2.0引入了<strong>server push</strong>，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。这样客户端可以直接从本地加载这些资源，不用再通过网络。</p>
</li>
</ol>
<h3 id="死锁的条件-如何避免"><a href="#死锁的条件-如何避免" class="headerlink" title="死锁的条件 如何避免"></a>死锁的条件 如何避免</h3><h4 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h4><ol>
<li>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。</li>
</ol>
<h4 id="避免与预防"><a href="#避免与预防" class="headerlink" title="避免与预防"></a>避免与预防</h4><h5 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h5><p>银行机算法，是否存在安全序列</p>
<h5 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h5><ol>
<li>破坏“不可剥夺”条件：一个进程不能获得所需要的全部资源时便处于等待状态，等待期间他占有的资源将被隐式的释放重新加入到系统的资源列表中，可以被其他的进程使用，而等待的进程只有重新获得自己原有的资源以及新申请的资源才可以重新启动执行。</li>
<li>破坏”请求与保持条件“：第一种方法静态分配，即每个进程在开始执行时就申请他所需要的全部资源。第二种是动态分配，即每个进程在申请所需要的资源时他本身不占用系统资源。</li>
<li>破坏“循环等待”条件：采用资源有序分配其基本思想是将系统中的所有资源顺序编号，将紧缺的、稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。</li>
</ol>
<h3 id="读写锁和互斥锁"><a href="#读写锁和互斥锁" class="headerlink" title="读写锁和互斥锁"></a>读写锁和互斥锁</h3><h4 id="互斥锁（ReentrantLock）"><a href="#互斥锁（ReentrantLock）" class="headerlink" title="互斥锁（ReentrantLock）"></a>互斥锁（ReentrantLock）</h4><p>是一次最多只能有一个线程持有的锁。</p>
<h4 id="读写锁-ReentrantReadWriteLock"><a href="#读写锁-ReentrantReadWriteLock" class="headerlink" title="读写锁(ReentrantReadWriteLock)"></a>读写锁(ReentrantReadWriteLock)</h4><p>允许一次读取多个线程，但一次只能写入一个线程。</p>
<ol>
<li><p>读加锁状态：读加锁的模式下，任何线程都可以对其进行读加锁的操作，但所有试图进行写加锁操作的线程都会被阻塞，直到所有读线程解锁。但是当读线程太多时，写线程一直被阻塞显然是不对的，所以一个线程想要对其进行写加锁时，就会阻塞读加锁，先让写加锁线程加锁。</p>
</li>
<li><p>写加锁状态：</p>
<p>写加锁的模式下，任何线程对其进行加锁操作都会被阻塞，直到解锁。如果没有线程正在读或写，那么一个线程可以访问写锁。读取锁允许多个reader线程同时持有，而写入锁最多只能有一个writer线程持有。</p>
</li>
</ol>
<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock其实是对读写锁的一种改进，它支持在读同时进行一个写操作,也就是说，它的性能将会比读写锁更快。更通俗的讲就是在读锁没有释放的时候是可以获取到一个写锁，获取到写锁之后，读锁阻塞，这一点和读写锁一致，唯一的区别在于读写锁不支持在没有释放读锁的时候获取写锁。有以下三种模式</p>
<h4 id="悲观读与写锁"><a href="#悲观读与写锁" class="headerlink" title="悲观读与写锁"></a>悲观读与写锁</h4><p>其中写锁和悲观读锁的语义与<a href="https://www.cnblogs.com/myworld7/p/12323467.html" target="_blank" rel="noopener">ReadWriteLock</a>中的写锁和读锁语义类似，允许多个线程同时获取悲观读锁，只允许一个线程获取写锁。与ReadWriteLock不同的是，StampedLock中的写锁和悲观读锁加锁成功之后，都会返回一个stamp标记，然后解锁的时候需要传入这个stamp。</p>
<h4 id="乐观读（无锁）"><a href="#乐观读（无锁）" class="headerlink" title="乐观读（无锁）"></a>乐观读（无锁）</h4><p>StampedLock提供了乐观读，当有多个线程同时读共享变量允许一个线程获取写锁，也就是说不是所有写操作都会被阻塞。</p>
<p>例如：我们将共享变量x，y读入方法的局部变量中，因为<code>tryOptimisticRead()</code>是无锁的，所以，共享变量x和y读入方法局部变量时，x和y有可能被其他线程修改了。因此，最后读完之后，还需要再次验证一下在读入过程中是否存在写操作，这个验证操作是通过调用<code>validate(stamp)</code>来实现的。<br>如果在执行乐观读操作期间，存在写操作，会把乐观读升级为悲观读锁。<br>如果不使用这种做法，那么就可能需要使用循环来执行反复读，直到执行乐观读操作的期间没有写操作，但是循环会浪费大量的CPU。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>  x, y;</span><br><span class="line">    <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="comment">// 计算到原点的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp = sl.tryOptimisticRead(); <span class="comment">//乐观读</span></span><br><span class="line">        <span class="comment">//读取全局变量存储到局部变量中 在读入的过程中，数据可能被修改</span></span><br><span class="line">        <span class="keyword">int</span> curX = x;</span><br><span class="line">        <span class="keyword">int</span> curY = y;</span><br><span class="line">        <span class="comment">//判断进行读操作期间，是否存在写操作，如果存在，则sl.validate(stamp)返回false</span></span><br><span class="line">        <span class="keyword">if</span>(!sl.validate(stamp)) &#123;</span><br><span class="line">            stamp = sl.readLock(); <span class="comment">//升级为悲观读锁 一切的写操作都会被阻塞</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                curX = x;</span><br><span class="line">                curY = y;      </span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp); <span class="comment">//释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(curX*curX + curY*curY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CAS-Synchronized取代Segment-ReentrantLock"><a href="#CAS-Synchronized取代Segment-ReentrantLock" class="headerlink" title="CAS+Synchronized取代Segment+ReentrantLock"></a>CAS+Synchronized取代Segment+ReentrantLock</h4><p>以前：首先在初始化ConcurrentHashMap的时候,会初始化一个Segment数组,容量为16,而每个Segment呢,都继承了ReentrantLock类,也就是说每个Segment类本身就是一个锁,之后Segment内部又有一个table数组,而每个table数组里的索引数据呢,又对应着一个Node链表.首先,当我们使用put方法的时候,是对我们的key进行hash拿到一个整型,然后将整型对16取模,拿到对应的Segment,之后调用Segment的put方法,然后上锁,请注意,这里lock()的时候其实是this.lock(),也就是说,每个Segment的锁是分开的，其中一个上锁不会影响另一个,此时也就代表了我可以有十六个线程进来,而ReentrantLock上锁的时候如果只有一个线程进来,是不会有线程挂起的操作的,也就是说只需要在AQS里使用CAS改变一个state的值为1,此时就能对代码进行操作,这样一来,我们等于将并发量16了.</p>
<p>现在：Synchronized是靠对象的对象头和此对象对应的monitor来保证上锁的,也就是对象头里的重量级锁标志指向了monitor,而monitor呢,内部则保存了一个当前线程,也就是抢到了锁的线程.它是对Node链表里的每一个Node加锁,也就是说,Synchronized是将每一个Node对象作为了一个锁,这样做的好处是什么呢?将锁细化了,也就是说,除非两个线程同时操作一个Node,注意,是一个Node而不是一个Node链表,那么才会争抢同一把锁.</p>
<p>如果使用ReentrantLock其实也可以将锁细化成这样的,只要让Node类继承ReentrantLock就行了,这样的话调用f.lock()就能做到和Synchronized(f)同样的效果,但为什么不这样做呢?</p>
<p>锁已经被细化到这种程度了,那么出现并发争抢的可能性还高吗?还有就是,哪怕出现争抢了,只要线程可以在30到50次自旋里拿到锁,那么Synchronized就不会升级为重量级锁,而等待的线程也就不用被挂起,我们也就少了挂起和唤醒这个上下文切换的过程开销.但如果是ReentrantLock呢?它则只有在线程没有抢到锁,然后新建Node节点后再尝试一次而已,不会自旋,而是直接被挂起,这样一来,我们就很容易会多出线程上下文开销的代价。</p>
<p>Synchronized和ReentrantLock他们的开销差距是在释放锁时唤醒线程的数量,Synchronized是唤醒锁池里所有的线程+刚好来访问的线程,而ReentrantLock则是当前线程后进来的第一个线程+刚好来访问的线程.</p>
<h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><p>锁的4种状态：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态（级别从低到高）</p>
<p><strong>偏向锁的升级</strong>（大多数时候是不存在锁竞争的，常常是一个线程多次获得同一个锁，因此如果每次都要竞争锁会增大很多没有必要付出的代价，为了降低获取锁的代价，才引入的偏向锁。）</p>
<p>当线程1访问代码块并获取锁对象时，会在java对象头和栈帧中记录偏向的锁的threadID，因为偏向锁不会主动释放锁，因此以后线程1再次获取锁的时候，需要比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p>
<p><strong>轻量级锁的升级</strong>（轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。）</p>
<p>线程1获取轻量级锁时会先把锁对象的<strong>对象头MarkWord复制一份到线程1的栈帧中创建的用于存储锁记录的空间</strong>（称为DisplacedMarkWord），然后<strong>使用CAS把对象头中的内容替换为线程1存储的锁记录（</strong>DisplacedMarkWord<strong>）的地址</strong>；如果在线程1复制对象头的同时（在线程1CAS之前），线程2也准备获取锁，复制了对象头到线程2的锁记录空间中，但是在线程2CAS的时候，发现线程1已经把对象头换了，<strong>线程2的CAS失败，那么线程2就尝试使用自旋锁来等待线程1释放锁</strong>。但是如果自旋的时间太长也不行，因为自旋是要消耗CPU的，因此自旋的次数是有限制的，比如10次或者100次，如果自旋次数到了线程1还没有释放锁，或者线程1还在执行，线程2还在自旋等待，这时又有一个线程3过来竞争这个锁对象，那么这个时候轻量级锁就会膨胀为重量级锁。重量级锁把除了拥有锁的线程都阻塞，防止CPU空转。<br>一句话就是<strong>锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</strong></p>
<h4 id="synchronized原理："><a href="#synchronized原理：" class="headerlink" title="synchronized原理："></a>synchronized原理：</h4><p>已知对象是存放在堆内存中的，对象大致可以分为三个部分，分别是<strong>对象头、实例变量和填充字节</strong>。</p>
<p>对象头的主要是由MarkWord和Klass Point(类型指针)组成，其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据。如果对象是数组对象，那么对象头占用3个字宽（Word），如果对象是非数组对象，那么对象头占用2个字宽。（1word = 2 Byte = 16 bit）<br>实例变量存储的是对象的属性信息，包括父类的属性信息，按照4字节对齐<br>填充字符，因为虚拟机要求对象字节必须是8字节的整数倍，填充字符就是用于凑齐这个整数倍的</p>
<p>![image-20210310223023276](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210310223023276.png)</p>
<p>Synchronized 是通过持有修饰对象的锁来实现同步的，而Synchronized锁对象是存在对象头的MarkWord中的，Synchronized关键字对应的是重量级锁：</p>
<p>Synchronized关键字对应的是重量级锁：</p>
<p>对于一个synchronized修饰的方法(代码块)来说：</p>
<p>1.当多个线程同时访问该方法，那么这些线程会先被放进_EntryList队列，此时线程处于blocking状态<br>2.当一个线程获取到了实例对象的监视器（monitor）锁，那么就可以进入running状态，执行方法，此时，ObjectMonitor对象的owner指向当前线程，count加1表示当前对象锁被一个线程获取<br>3.当running状态的线程调用wait()方法，那么当前线程释放monitor对象，进入waiting状态，ObjectMonitor对象的owner变为null，count减1，同时线程进入WaitSet队列，直到有线程调用notify()方法唤醒该线程，则该线程重新获取monitor对象进入Owner区<br>4.如果当前线程执行完毕，那么也释放monitor对象，进入waiting状态，ObjectMonitor对象的_owner变为null，_count减1</p>
<p><strong>不管是方法同步还是代码块同步都是基于进入和退出monitor对象来实现</strong></p>
<ol>
<li>Synchronized代码块同步在需要同步的代码块开始的位置插入monitorentry指令，在同步结束的位置或者异常出现的位置插入monitorexit指令；JVM要保证monitorentry和monitorexit都是成对出现的，任何对象都有一个monitor与之对应，当这个对象的monitor被持有以后，它将处于锁定状态</li>
<li>Synchronized方法同步不再是通过插入monitorentry和monitorexit指令实现，而是由方法调用指令来读取运行时常量池中的ACC_SYNCHRONIZED标志隐式实现的，如果方法表结构（method_info Structure）中的ACC_SYNCHRONIZED标志被设置，那么线程在执行方法前会先去获取对象的monitor对象，如果获取成功则执行方法代码，执行完毕后释放monitor对象，如果monitor对象已经被其它线程获取，那么当前线程被阻塞。</li>
</ol>
<h3 id="select、poll和epoll"><a href="#select、poll和epoll" class="headerlink" title="select、poll和epoll"></a>select、poll和epoll</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p><strong>epoll可以理解为event poll</strong>，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是<strong>事件驱动（每个事件关联上fd）</strong>的，此时我们对这些流的操作都是有意义的。<strong>（复杂度降低到了O(1)）</strong></p>
<p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</p>
<h4 id="IO与NIO？"><a href="#IO与NIO？" class="headerlink" title="IO与NIO？"></a>IO与NIO？</h4><ol>
<li><p>Java IO和NIO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
</li>
<li><p>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。  NIO通讯是将整个任务切换成许多小任务，由一个线程负责处理所有io事件，并负责分发。它是利用<strong>事件驱动机制</strong>，而不是监听机制，事件到的时候再触发。NIO线程之间通过wait，notify等方式通讯。保证了每次上下文切换都有意义，减少无谓的进程切换。<strong>本质上是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写</strong></p>
</li>
<li><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
</li>
<li><p>BIO：同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p>
</li>
<li><p>AIO：异步非阻塞，在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。</p>
</li>
<li><p><strong>零拷贝</strong>：传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和应用程序地址空间定义的缓冲区之间进行传输。<br>零拷贝主要的任务就是<strong>避免</strong>CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。<br>传统：当应用程序访问某块数据时，操作系统首先会检查，是不是最近访问过此文件，文件内容是否缓存在内核缓冲区，如果是，操作系统则直接根据<code>read</code>系统调用提供的<code>buf</code>地址，将内核缓冲区的内容拷贝到<code>buf</code>所指定的用户空间缓冲区中去。如果不是，操作系统则首先将磁盘上的数据拷贝的内核缓冲区，这一步目前主要依靠<code>DMA</code>来传输，然后再把内核缓冲区上的内容拷贝到用户缓冲区中。接下来，<code>write</code>系统调用再把用户缓冲区的内容拷贝到网络堆栈相关的内核缓冲区中，最后<code>socket</code>再把内核缓冲区的内容发送到网卡上。</p>
<p>![image-20210405181030057](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210405181030057.png)</p>
<p><code>sendfile</code>系统调用利用<code>DMA</code>引擎将文件内容拷贝到内核缓冲区去，然后将带有文件位置和长度信息的缓冲区描述符添加socket缓冲区去，这一步不会将内核中的数据拷贝到socket缓冲区中，<code>DMA</code>引擎会将内核缓冲区的数据拷贝到协议引擎中去，避免了最后一次拷贝。</p>
</li>
</ol>
<p>![image-20210405181532377](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210405181532377.png)</p>
<h3 id="类加载机制，双亲委派及其打破"><a href="#类加载机制，双亲委派及其打破" class="headerlink" title="类加载机制，双亲委派及其打破"></a>类加载机制，双亲委派及其打破</h3><h4 id="什么时候类加载"><a href="#什么时候类加载" class="headerlink" title="什么时候类加载"></a>什么时候类加载</h4><ul>
<li>隐式加载 new 创建类的实例</li>
<li>显式加载：loaderClass,forName等</li>
<li>访问类的静态变量，或者为静态变量赋值</li>
<li>调用类的静态方法</li>
<li>使用反射方式创建某个类或者接口对象的Class对象。</li>
<li>初始化某个类的子类</li>
<li>直接使用<code>java.exe</code>命令来运行某个主类</li>
</ul>
<h4 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h4><p>我们编写的java文件都是保存着业务逻辑代码。java编译器将 .java 文件编译成扩展名为 .class 的文件。.class 文件中保存着java转换后，虚拟机将要执行的指令。当需要某个类的时候，java虚拟机会加载 .class 文件，并创建对应的class对象，将class文件加载到虚拟机的内存，这个过程被称为类的加载：</p>
<ol>
<li><strong>加载</strong> ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象</li>
<li><strong>验证</strong> 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。</li>
<li><strong>准备</strong> 为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。</li>
<li><strong>解析</strong> 这里主要的任务是把常量池中的符号引用替换成直接引用</li>
<li><strong>初始化</strong> 这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）</li>
</ol>
<p><strong>forName</strong> 和 <strong>loaderClass</strong> 的区别</p>
<ul>
<li>Class.forName()得到的class是已经初始化完成的。</li>
<li>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</li>
</ul>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>双亲委派模式要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器，但是在双亲委派模式中父子关系采取的并不是继承的关系，而是采用<strong>组合关系</strong>来复用父类加载器的相关代码。按照由父级到子级的顺序，类加载器主要包含以下几个：</p>
<ul>
<li><strong>BootstrapClassLoader</strong>（启动类加载器）:主要负责加载核心的类库(java.lang.*等),JVM_HOME/lib目录下的，构造ExtClassLoader和APPClassLoader。</li>
<li><strong>ExtClassLoader</strong> (拓展类加载器)：主要负责加载jre/lib/ext目录下的一些扩展的jar</li>
<li><strong>AppletClassLoader</strong>（系统类加载器）:主要负责加载应用程序的主函数类</li>
<li><strong>自定义类加载器</strong>:主要负责加载应用程序的主函数类</li>
</ul>
<p>如果一个类收到了类加载的请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最后到达顶层的启动类加载器，如果父类能够完成类的加载任务，就会成功返回，倘若父类加载器无法完成任务，子类加载器才会尝试自己去加载，这就是双亲委派模式。</p>
<p>JVM中表示两个class对象是否为同一个类的必要条件：</p>
<ol>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的Class Loader必须相同</li>
</ol>
<h4 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h4><p>由于BootstrapClassloader是顶级类加载器，BootstrapClassloader无法委派AppClassLoader来加载类，也就是说BootstrapClassloader中加载的类中无法使用由AppClassLoader加载的类。可能绝大部分情况这个不算是问题，因为BootstrapClassloader加载的都是基础类，供AppClassLoader加载的类调用的类。但是万事万物都不是绝对的比如经典的JAVA SPI机制。</p>
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。</p>
<p>线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源。</p>
<p>![image-20210406101114942](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210406101114942.png)</p>
<h3 id="Object类里面的方法"><a href="#Object类里面的方法" class="headerlink" title="Object类里面的方法"></a>Object类里面的方法</h3><ol>
<li><p>getClass方法</p>
<p>返回运行时类型，返回值为class对象</p>
</li>
<li><p>hashCode方法</p>
<p>返回该对象的哈希吗值</p>
</li>
<li><p>equals方法</p>
<p>判断两个对象是否相等，在Object源码中equals就是使用==去判断，所以在Object中equals是等价于==的，但是在String及某些类对equals进行了重写，实现不同的比较。</p>
</li>
<li><p>clone方法</p>
<p>用于创建并返回一个对象的拷贝。</p>
<p>clone 方法是浅拷贝，对象内属性引用的对象只会拷贝引用地址，而不会将引用的对象重新分配内存，相对应的深拷贝则会连引用的对象也重新创建。</p>
</li>
<li><p>toString方法</p>
<p>返回一个String字符串,用于描述当前对象的信息,可以重写返回对自己有用的信息，默认返回的是当前对象的类名+hashCode的16进制数字。</p>
</li>
<li><p>wait方法</p>
<p>多线程时用到的方法，作用是让当前线程进入等待状态，同时也会让当前线程释放它所持有的锁。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，当前线程被唤醒</p>
</li>
<li><p>notify方法</p>
<p>多线程时用到的方法，唤醒该对象等待的某个线程</p>
</li>
<li><p>notifyAll方法</p>
<p>多线程时用到的方法，唤醒该对象等待的所有线程</p>
</li>
<li><p>finalize方法</p>
<p>对象在被GC释放之前一定会调用finalize方法，对象被释放前最后的挣扎,因为无法确定该方法什么时候被调用，很少使用。</p>
</li>
</ol>
<h3 id="实现线程的几种方式"><a href="#实现线程的几种方式" class="headerlink" title="实现线程的几种方式"></a>实现线程的几种方式</h3><h4 id="无返回值类型的"><a href="#无返回值类型的" class="headerlink" title="无返回值类型的"></a>无返回值类型的</h4><ol>
<li>继承Thread类，实现Thread类的run方法</li>
<li>实现Runnable接口，重写run方法</li>
</ol>
<h4 id="有返回值类型的"><a href="#有返回值类型的" class="headerlink" title="有返回值类型的"></a>有返回值类型的</h4><ol>
<li>实现Callble接口，重写call方法。<br>调用的时候，需要使用FutureTask这个类的有参构造（FutureTask task = new FutureTask(new CallableDemo())），再使用thread类的有参构造(new Thread(task.run()))。最后使用task.get()方法获取返回值。</li>
<li>使用线程池创建线程，可以有返回值，也可以没有返回值。使用Executory顶级接口处理。</li>
</ol>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><ol>
<li>newFixedThreadPool创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li>
<li>newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。</li>
<li>newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO,LIFO,优先级)执行。</li>
</ol>
<h4 id="七大参数"><a href="#七大参数" class="headerlink" title="七大参数"></a>七大参数</h4><p> (1）corePoolSize：线程池中常驻核心线程数</p>
<p>（2）maximumPoolSize：线程池能够容纳同时执行的最大线程数，此值必须大于等于1</p>
<p>（3）keepAliveTime：多余的空闲线程存活时间。当前线程池数量超过corePoolSize时，当空闲时间到达keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止。</p>
<p>（4）unit：keepAliveTime的时间单位</p>
<p>（5）workQueue：任务队列，被提交但尚未执行的任务</p>
<p>（6）threadFactory：表示生成线程池中的工作线程的线程工厂，用于创建线程，一般为默认线程工厂即可</p>
<p>（7）handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝来请求的Runnable的策略</p>
<h4 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h4><p><strong>（1）AbortPolicy</strong>（默认）</p>
<p>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</p>
<p>这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现。</p>
<p><strong>（2）DiscardPolicy</strong></p>
<p>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</p>
<p>使用此策略，可能会使我们无法发现系统的异常状态。建议是一些无关紧要的业务采用此策略。例如一些博客网站统计阅读量就是采用的这种拒绝策略。</p>
<p><strong>（3）DiscardOldestPolicy</strong></p>
<p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</p>
<p>此拒绝策略，是一种喜新厌旧的拒绝策略。是否要采用此种拒绝策略，还得根据实际业务是否允许丢弃老任务来认真衡量。</p>
<p><strong>（4）CallerRunsPolicy</strong></p>
<p>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务，如果任务被拒绝了，则由调用线程（提交任务的线程）直接执行此任务。第一点新提交的任务不会被丢弃，这样也就不会造成业务损失。 第二点好处是，由于谁提交任务谁就要负责执行任务，这样提交任务的线程就得负责执行任务，而执行任务又是比较耗时的，在这段期间，提交任务的线程被占用，也就不会再提交新的任务，减缓了任务提交的速度，相当于是一个负反馈。在此期间，线程池中的线程也可以充分利用这段时间来执行掉一部分任务，腾出一定的空间，相当于是给了线程池一定的缓冲期。</p>
<p><strong>（5）自定义</strong></p>
<p>实现 RejectedExecutionHandler 接口来实现自己的拒绝策略，重写rejectedExecution方法；如打印日志、暂存任务、重新执行等。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p>
<p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
<p>ThreadLocal的作用主要是做<strong>数据隔离</strong>，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，防止自己的变量被其它线程篡改。</p>
<h4 id="什么情况使用ThreadLocal"><a href="#什么情况使用ThreadLocal" class="headerlink" title="什么情况使用ThreadLocal"></a>什么情况使用ThreadLocal</h4><ol>
<li><p>spring采用ThreadLocal操作数据库，实现事物隔离，来保证单个线程中的数据库操作使用的是同一个数据库连接，同时，采用这种方式可以使业务层使用事务时不需要感知并管理connection对象。</p>
</li>
<li><p>项目中发现部分用户的日期居然不对了，排查下来是SimpleDataFormat的锅，当时我们使用SimpleDataFormat的parse()方法，内部有一个Calendar对象，调用SimpleDataFormat的parse()方法会先调用Calendar.clear（），然后调用Calendar.add()，如果一个线程先调用了add()然后另一个线程又调用了clear()，这时候parse()方法解析的时间就不对了。</p>
<p>其实要解决这个问题很简单，让每个线程都new 一个自己的 SimpleDataFormat就好了，但是1000个线程难道new1000个SimpleDataFormat？</p>
<p>所以当时我们使用了线程池加上ThreadLocal包装SimpleDataFormat，再调用initialValue让每个线程有一个SimpleDataFormat的副本，从而解决了线程安全的问题，也提高了性能。</p>
</li>
<li><p>我看了一下很多场景的cookie，session等数据隔离都是通过ThreadLocal去做实现的。</p>
</li>
</ol>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>先看看他的使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; localName = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">localName.set(<span class="string">"张三"</span>);</span><br><span class="line">String name = localName.get();</span><br><span class="line">localName.remove();</span><br></pre></td></tr></table></figure>

<p>线程进来之后初始化一个可以泛型的ThreadLocal对象，之后这个线程只要在remove之前去get，都能拿到之前set的值。</p>
<p>而他的set方法中有一个ThreadLocalMap,它并未实现Map接口，而且他的Entry是继承WeakReference（弱引用）的，也没有看到HashMap中的next，所以不存在链表了。<strong>ThreadLocalMap是ThreadLocal的一个内部类。用Entry类来进行存储</strong>，我们的<strong>值都是存储到这个Map上的，key是当前ThreadLocal对象</strong>！（<strong>hreadLocal本身并不存储值</strong>，它只是<strong>作为一个key来让线程从ThreadLocalMap获取value</strong>）</p>
<h4 id="堆还是栈？"><a href="#堆还是栈？" class="headerlink" title="堆还是栈？"></a>堆还是栈？</h4><p>在Java中，栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，而堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。ThreadLocal实例实际上也是被其创建的类持有（更顶端应该是被线程持有），而ThreadLocal的值其实也是被线程实例持有，它们都是位于<strong>堆</strong>上，只是通过一些技巧将可见性修改成了线程可见。</p>
<p>![image-20210409145236004](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210409145236004.png)</p>
<p>![image-20210409145251482](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210409145251482.png)</p>
<h4 id="内存泄漏？"><a href="#内存泄漏？" class="headerlink" title="内存泄漏？"></a>内存泄漏？</h4><p>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，解决办法：每次使用完ThreadLocal都调用它的remove()方法清除数据。</p>
<p>（hreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部<strong>强引用</strong>时，Key(ThreadLocal)势必会被GC回收，这样就会导致ThreadLocalMap中key为null， 而value还存在着强引用，只有thead线程退出以后,value的强引用链条才会断掉。）但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p>
<blockquote>
<p>Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value</p>
</blockquote>
<h4 id="为什么使用弱引用"><a href="#为什么使用弱引用" class="headerlink" title="为什么使用弱引用"></a>为什么使用弱引用</h4><h5 id="key-使用强引用"><a href="#key-使用强引用" class="headerlink" title="key 使用强引用"></a>key 使用强引用</h5><p>当hreadLocalMap的key为强引用回收ThreadLocal时，因为ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p>
<h5 id="key使用弱引用"><a href="#key使用弱引用" class="headerlink" title="key使用弱引用"></a>key使用弱引用</h5><p>当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。</p>
<h3 id="myIsam和innodb"><a href="#myIsam和innodb" class="headerlink" title="myIsam和innodb"></a>myIsam和innodb</h3><ol>
<li><p>**InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务； </p>
</li>
<li><p>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</p>
</li>
<li><p>InnoDB是聚集索引，使用B+Tree作为索引结构，数据文件是和（主键）索引绑在一起的（表数据文件本身就是按B+Tree组织的一个索引结构），必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。</p>
<p>MyISAM是非聚集索引，也是使用B+Tree作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</p>
<p>也就是说<strong>：InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</strong></p>
</li>
<li><p><strong>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快（注意不能加有任何WHERE条件）</strong></p>
<p>因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询</p>
</li>
<li><p><strong>InnoDB支持表、行(默认)级锁，而MyISAM支持表级锁</strong></p>
<p>   InnoDB的行锁是实现在索引上的，而不是锁在物理行记录上。潜台词是，如果访问没有命中索引，也无法使用行锁，将要退化为表锁。</p>
</li>
</ol>
<h3 id="innodb引擎的五大特性"><a href="#innodb引擎的五大特性" class="headerlink" title="innodb引擎的五大特性"></a><strong>innodb引擎的五大特性</strong></h3><ol>
<li><p>插入缓冲</p>
<p>InnoDB存储引擎中，主键是行唯一的标识符，通常应用程序插入行记录是顺序的，所以插入聚集索引一般也是顺序的。表中的非聚集索引（辅助索引）在进行插入的时候，数据页的存放还按照主键进行顺序存放，但是对于非聚集索引叶子结点的插入就不是顺序的，这时候需要离散的访问非聚集索引，由于随机读取的存在而导致了插入操作的性能下降。（在一般情况下辅助索引是比较顺序的）。</p>
<p>InnoDB设计了Insert Buffer，对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在直接插入，如果不在，则先放入到一个Insert Buffer对象中。然后再以一定的频率和情况进行Insert Buffer和辅助索引叶子节点的Merge（合并）操作，通常能将多个插入缓冲合并到一个操作中（因为在一个索引页中），这就大大提高了非聚集索引插入的性能。</p>
<p>使用Insert Buffer需要满足的条件：<strong>1.索引是辅助索引；2.索引不是unique索引</strong></p>
</li>
<li><p>两次写</p>
<p>doublewrite由两部分组成，一部分为内存中的doublewrite buffer，其大小为2MB，另一部分是磁盘上共享表空间（ibdata x）中连续的128个页，即2个区（extent），大小也是2M。doublewrite工作流程如下：</p>
<pre><code>1、当一系列机制（main函数触发、checkpoint等）触发数据缓冲池中的脏页进行刷新时，并不直接写磁盘，而是会将脏页先复制到内存中的doublewrite buffer,之后通过doublewrite buffer再分两次、每次1MB顺序写入共享表空间的物理磁盘上。
2、马上调用fsync函数，同步脏页进磁盘</code></pre><p>   由于在这个过程中，doublewrite页的存储是连续的，因此写入磁盘为顺序写，性能很高；完成doublewrite后，再将脏页写入实际的各个表空间文件，这时写入就是离散的了。</p>
</li>
<li><p>自适应哈希索引</p>
<p>InnoDB存储引擎会监控对表上索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应（adaptive）的。自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。而且不需要将整个表都建哈希索引，InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。<strong>哈希索引只能用来搜索等值的查询</strong></p>
</li>
<li><p>异步IO</p>
<p>为了提高磁盘操作性能，当前的数据库系统都采用AIO进行磁盘处理。</p>
</li>
<li><p>刷新临接页</p>
<p>当刷新一个脏页时，innodb存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写入操作合并为一个IO操作，增大写入量，减少了物理写IO，故该工作机制在传统机械磁盘下有着显著的优势。</p>
</li>
</ol>
<h3 id="JVM内存区域和java内存模型"><a href="#JVM内存区域和java内存模型" class="headerlink" title="JVM内存区域和java内存模型"></a>JVM内存区域和java内存模型</h3><h4 id="内存区域和OOM"><a href="#内存区域和OOM" class="headerlink" title="内存区域和OOM"></a>内存区域和OOM</h4><p>按照JVM规范，JAVA虚拟机在运行时会管理以下的内存区域：</p>
<p>​    <strong>程序计数器：</strong>当前线程执行的字节码的行号指示器，线程私有<br>​    <strong>JAVA虚拟机栈</strong>：Java方法执行的内存模型，每个Java方法的执行对应着一个栈帧的进栈和出栈的操作。<br>​    <strong>本地方法栈</strong>：类似“ JAVA虚拟机栈 ”，为native方法的运行提供内存环境。<br>​    <strong>JAVA堆</strong>：对象内存分配的地方，内存垃圾回收的主要区域，所有线程共享。可分为新生代，老生代。<br>​    <strong>方法区：</strong>用于存储已经被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Hotspot中的“永久代”。<br>​    <strong>运行时常量池</strong>：方法区的一部分，存储常量信息，如各种字面量、符号引用等。<br>​    <strong>直接内存</strong>：并不是JVM运行时数据区的一部分， 可直接访问的内存， 比如NIO会用到这部分。</p>
<p>![image-20210318154532539](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210318154532539.png)</p>
<p>按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。</p>
<p>最常见的OOM情况有以下三种：</p>
<p><strong>java.lang.OutOfMemoryError: Java heap space</strong> ——&gt;java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。<br><strong>java.lang.OutOfMemoryError: PermGen space</strong> ——&gt;java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。<br><strong>java.lang.StackOverflowError</strong> ——&gt; 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。</p>
<h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p>JMM中规定所有的变量都存储在主内存（Main Memory）中，每条线程都有自己的工作内存（Work Memory），线程的工作内存中保存了该线程所使用的变量的从主内存中拷贝的副本。线程对于变量的读、写都必须在工作内存中进行，而不能直接读、写主内存中的变量。同时，本线程的工作内存的变量也无法被其他线程直接访问，必须通过主内存完成。</p>
<p>对于普通共享变量，线程A将变量修改后，体现在此线程的工作内存。在尚未同步到主内存时，若线程B使用此变量，从主内存中获取到的是修改前的值，便发生了共享变量值的不一致，也就是出现了<strong>线程的可见性问题</strong>。</p>
<h5 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h5><p><code>volatile</code>定义：</p>
<ul>
<li>当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</li>
<li>写操作会导致其他线程中的缓存无效</li>
</ul>
<p>这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。</p>
<p><code>volatile</code>是通过编译器在生成字节码时，在指令序列中添加“<strong>内存屏障</strong>”来禁止指令重排序的。</p>
<ul>
<li><strong>LoadLoad屏障</strong>： 对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li>
<li><strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li>
<li><strong>StoreLoad屏障</strong>： 对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li>
</ul>
<p>JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。</p>
<h5 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h5><p>编译器为了提高指令执行效率，是可以对指令重排序的，重排序后指令的执行顺序不一样，有可能线程2读取某个变量时，线程1还未进行写入操作。<strong>对于两个操作A和B，这两个操作可以在不同的线程中执行。如果A Happens-Before B，那么可以保证，当A操作执行完后，A操作的执行结果对B操作是可见的。</strong>包括以下规则：</p>
<p><strong>程序顺序规则</strong>：在一个线程内部，按照程序代码的<strong>书写</strong>顺序，书写在前面的代码操作Happens-Before书写在后面的代码操作。这时因为<em>Java语言规范</em>要求JVM在单个线程内部要维护类似严格串行的语义，如果多个操作之间有先后依赖关系，则不允许对这些操作进行重排序。</p>
<p><strong>锁定规则</strong>：对锁M解锁之前的<strong>所有</strong>操作Happens-Before对锁M加锁之后的<strong>所有</strong>操作。</p>
<p><strong>volatile变量规则</strong>：对一个volatile变量的写操作及这个写操作之前的所有操作Happens-Before对这个变量的读操作及这个读操作之后的所有操作。</p>
<p><strong>线程终止规则：</strong>线程中的任何操作都Happens-Before其它线程检测到该线程已经结束。假设两个线程s、t。在线程s中调用t.join()方法。则线程s会被挂起，等待t线程运行结束才能恢复执行。当t.join()成功返回时，s线程就知道t线程已经结束了。所以根据本条原则，在t线程中对共享变量的修改，对s线程都是可见的。</p>
<p><strong>中断规则：</strong>一个线程在另一个线程上调用interrupt,Happens-Before被中断线程检测到interrupt被调用。假设两个线程A和B，A先做了一些操作operationA，然后调用B线程的interrupt方法。当B线程感知到自己的中断标识被设置时(通过抛出InterruptedException，或调用interrupted和isInterrupted),operationA中的操作结果对B都是可见的。</p>
<p><strong>传递性规则：</strong>如果操作A Happens-Before B，B Happens-Before C，那么可以得出操作A Happens-Before C。</p>
<p><strong><em>重排序</em>和<em>CPU高速缓存</em>有利于计算机性能的提高，但却对多CPU处理的一致性带来了影响。为了解决这个矛盾，我们可以采取一种折中的办法。我们用分割线把整个程序划分成几个程序块，在每个程序块内部的指令是可以重排序的，但是分割线上的指令与程序块的其它指令之间是不可以重排序的。在一个程序块内部，CPU不用每次都与主内存进行交互，只需要在CPU缓存中执行读写操作即可，但是当程序执行到分割线处，CPU必须将执行结果同步到主内存或从主内存读取最新的变量值。那么，Happens-Before规则就是定义了这些程序块的分割线。</strong></p>
<h3 id="缓存失效和缓存穿透解决办法"><a href="#缓存失效和缓存穿透解决办法" class="headerlink" title="缓存失效和缓存穿透解决办法"></a>缓存失效和缓存穿透解决办法</h3><p><strong>缓存失效</strong>：</p>
<p>引起这个原因的主要因素是高并发下，我们一般设定一个缓存的过期时间时，可能有一些会设置5分钟啊，10分钟这些；并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间在同一时刻，这个时候就可能引发——当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p>
<p>处理方法：</p>
<p>一个简单方案就是将缓存失效时间分散开，不要所以缓存时间长度都设置成5分钟或者10分钟；比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p>缓存失效时产生的雪崩效应，将所有请求全部放在数据库上，这样很容易就达到数据库的瓶颈，导致服务无法正常提供。尽量避免这种场景的发生。</p>
<p><strong>缓存穿透</strong>：</p>
<p>　　出现场景：指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。</p>
<p>　　当在流量较大时，出现这样的情况，一直请求DB，很容易导致服务挂掉。</p>
<p>处理方法：</p>
<p>　　　　方法1.在封装的缓存SET和GET部分增加个步骤，如果查询一个KEY不存在，就已这个KEY为前缀设定一个标识KEY；以后再查询该KEY的时候，先查询标识KEY，如果标识KEY存在，就返回一个协定好的非false或者NULL值，然后APP做相应的处理，这样缓存层就不会被穿透。当然这个验证KEY的失效时间不能太长。</p>
<p>　　　　方法2.如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，一般只有几分钟。</p>
<p>　　　　方法3.采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<ol>
<li>首先需要k个hash函数，每个函数可以把key散列成为1个整数<ol start="2">
<li>初始化时，需要一个长度为n比特的数组，每个比特位初始化为0<ol start="3">
<li>某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1<ol start="4">
<li>判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>优点：</p>
<p>不需要存储key，节省空间</p>
<p>缺点：</p>
<ol>
<li>算法判断key在集合中时，有一定的概率key其实不在集合中</li>
<li>无法删除</li>
</ol>
<h3 id="Spring-Bean加载流程"><a href="#Spring-Bean加载流程" class="headerlink" title="Spring Bean加载流程"></a>Spring Bean加载流程</h3><p>单例对象在加载Spring配置文件的时候就创建出来了，非单例对象在每一次使用的时候通过getBean创建。</p>
<ol>
<li>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化。Bean实例化后对将Bean的引入和值注入到Bean的属性中</li>
<li>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法（<strong>Aware</strong>类型的接口<code>的作用就是</code><strong>让我们能够拿到Spring容器中的一些资源</strong>）</li>
<li>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</li>
<li>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。</li>
<li>如果Bean实现了BeanPostProcessor接口，调用预初始化方法</li>
<li>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。</li>
<li>如果bean使用init-method声明了初始化方法，该方法也会被调</li>
<li>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法</li>
<li>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁</li>
<li>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用</li>
</ol>
<p><strong>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</strong></p>
<h3 id="AOP动态代理"><a href="#AOP动态代理" class="headerlink" title="AOP动态代理"></a>AOP动态代理</h3><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理是通过java.lang.reflect.Proxy 类来实现的，我们可以调用Proxy类的newProxyInstance()方法来创建代理对象。对于使用业务接口的类，Spring默认会使用JDK动态代理来实现AOP。</p>
<p>实现了InvocationHandler接口，并实现了接口中的invoke()方法，所有动态代理类所调用的方法都会交由该方法处理。在invoke()方法中，目标类方法执行的前后可以实现一些增强方法。在创建的代理方法createProxy()中，使用了Proxy类的newProxyInstance()方法来创建代理对象。newProxyInstance()方法中包含3个参数，其中第1个参数是当前类的类加载器，第2个参数表示的是被代理对象实现的所有接口，第3个参数this代表的就是代理类JdkProxy本身。</p>
<h4 id="CGLB动态代理"><a href="#CGLB动态代理" class="headerlink" title="CGLB动态代理"></a>CGLB动态代理</h4><p>如果想代理没有实现接口的类，那么可以使用CGLIB代理.<br>CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它采用非常底层的字节码技术，对指定的目标类生成一个子类，并对子类进行增强</p>
<p>创建代理类CglibProxy，该代理类需要实现MethodInterceptor接口，并实现接口中的intercept()方法。</p>
<p>首先创建了一个动态类对象Enhancer，它是CGLIB的核心类；然后调用了Enhancer类的setSuperclass()方法来确定目标对象；接下来调用了setCallback()方法添加回调函数，其中的this代表的就是代理类CglibProxy本身。最后通过return 语句将创建的代理类对象返回。intercept()方法会在程序执行目标方法时被调用，方法运行时奖会执行切面类中的增强方法。</p>
<h3 id="Resource-和-Autowire-注解有什么区别？"><a href="#Resource-和-Autowire-注解有什么区别？" class="headerlink" title="@Resource 和 @Autowire 注解有什么区别？"></a>@Resource 和 @Autowire 注解有什么区别？</h3><p>他们都可以实现bean的注入</p>
<h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>@Resource 这属于java自带的注解；按照name属性进行注入，使用@Resource可以减少代码和Spring之间的耦合。</p>
<h4 id="Autowire"><a href="#Autowire" class="headerlink" title="@Autowire"></a>@Autowire</h4><p>@Autowired是spring的注解，默认是按照类型来注入的，默认情况下要求依赖对象必须存在；如果允许依赖对象为null，需设置required属性为false。</p>
<p>如果同时指定name和type属性，则找到唯一匹配的bean装配，未找到则抛异常；<br>如果指定name属性，则按照名称(by-name)装配，未找到则抛异常；<br>如果指定type属性，则按照类型(by-type)装配，未找到或者找到多个则抛异常；<br>既未指定name属性，又未指定type属性，则按照名称(by-name)装配；如果未找到，则按照类型(by-type)装配。</p>
<h3 id="BeanFactory-和-ApplicationContext-有什么区别？"><a href="#BeanFactory-和-ApplicationContext-有什么区别？" class="headerlink" title="BeanFactory 和 ApplicationContext 有什么区别？"></a>BeanFactory 和 ApplicationContext 有什么区别？</h3><p><strong>1、国际化</strong></p>
<p>BeanFactory是不支持国际化功能的，因为BeanFactory没有扩展Spring中MessageResource接口。相反，由于Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext扩展了MessageResource接口，因而具有消息处理的能力(i18N)</p>
<p><strong>2、强大的事件机制(Event)</strong> </p>
<p>基本上牵涉到事件(Event)方面的设计，就离不开观察者模式，<br>ApplicationContext的事件机制主要通过ApplicationEvent和ApplicationListener这两个接口来提供的，和<a href="https://coding.imooc.com/?c=java" target="_blank" rel="noopener">java</a> swing中的事件机制一样。即当ApplicatioContext中发布一个事件的时，所有扩展了ApplicationListener的Bean都将会接受到这个事件，并进行相应的处理。</p>
<p><strong>3、底层资源的访问</strong> </p>
<p>ApplicatioContext扩展了ResourceLoader(资源加载器)接口，从而可以用来加载多个Resource，而BeanFactory是没有扩展ResourceLoader</p>
<p><strong>4、延迟加载</strong> </p>
<p>BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的spring的配置问题。而Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext则相反，它是在<a href="https://coding.imooc.com/?c=container" target="_blank" rel="noopener">容器</a>启动时，一次性创建了所有的Bean。这样，在<a href="https://coding.imooc.com/?c=container" target="_blank" rel="noopener">容器</a>启动时，我们就可以发现Spring中存在的配置错误。</p>
<p>BeanFactory和Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext都支持BeanPostProcessor（前置处理）、BeanFactoryPostProcessor（后置处理）的使用，但两者之间的区别是：BeanFactory需要手动注册，而Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext则是自动注册</p>
<p><strong>5、总结</strong></p>
<p>Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext继承了BeanFactory，BeanFactory是Spring中比较原始的Factory，它不支持AOP、Web等Spring插件，而Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext不仅包含了BeanFactory的所有功能，还支持Spring的各种插件，还以一种面向框架的方式工作以及对上下文进行分层和实现继承。<br>BeanFactory是Spring框架的基础设施，面向Spring本身；而Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext面向使用Spring的开发者，相比BeanFactory提供了更多面向实际应用的功能，几乎所有场合都可以直接使用Application<a href="https://coding.imooc.com/?c=c" target="_blank" rel="noopener">C</a>ontext而不是底层的BeanFactory</p>
<h3 id="GET-POST"><a href="#GET-POST" class="headerlink" title="GET POST"></a>GET POST</h3><p>1）Get， 它用于获取信息，注意，他只是获取、查询数据，也就是说它不会修改服务器上的数据，从这点来讲，它是数据安全的，而稍后会提到的Post它是可以修改数据的，所以这也是两者差别之一了。</p>
<p>2） Post，它是可以向服务器发送修改请求，从而<strong>修改服务器</strong>的，比方说，我们要在论坛上回贴、在博客上评论，这就要用到Post了，当然它也是可以仅仅获取数据的。</p>
<p>3）GET提交的数据比较少，最多1024B，因为GET数据是附在URL之后的，而URL则会受到不同环境的限制的，比如说IE对其限制为2K+35，而POST可以传送更多的数据（理论上是没有限制的，但一般也会受不同的环境，如浏览器、<a href="http://lib.csdn.net/base/operatingsystem" target="_blank" rel="noopener">操作系统</a>、服务器处理能力等限制，IIS4可支持80KB，IIS5可支持100KB）。</p>
<p>4）Post的安全性要比Get高，因为Get时，参数数据是明文传输的，而POST数据则可以加密的，但GET的速度可能会快些。</p>
<h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务</p>
<p>本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。</p>
<p>远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？</p>
<h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。对NoSQL最普遍的解释是”非关联型的”，强调<strong>Key-Value Stores</strong>和文档数据库的优点</p>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:</p>
<ul>
<li><strong>一致性(Consistency)</strong> (所有节点在同一时间具有相同的数据)</li>
<li><strong>可用性(Availability)</strong> (保证每个请求不管成功或者失败都有响应)</li>
<li><strong>分隔容忍(Partition tolerance)</strong> (系统中任意信息的丢失或失败不会影响系统的继续运作)</li>
</ul>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p>
<p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p>
<ul>
<li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li>
<li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。（HBase,Redis,MongoDB）</li>
<li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li>
</ul>
<h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:</p>
<ul>
<li>Basically Available –基本可用<ul>
<li><strong>响应时间上的损失</strong>：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li><strong>功能上的损失</strong>：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
</li>
<li>Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的；是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</strong>。</li>
<li>Eventually Consistency – 最终一致性， 也是 ACID 的最终目的。<strong>最终一致性</strong>强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<h3 id="Spring-七种事务传播属性和五种隔离级别"><a href="#Spring-七种事务传播属性和五种隔离级别" class="headerlink" title="Spring 七种事务传播属性和五种隔离级别"></a>Spring 七种事务传播属性和五种隔离级别</h3><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 例如：methodA事务方法调用methodB事务方法时，methodB是继续在调用者methodA的事务中运行呢，还是为自己开启一个新事务运行，这就是由methodB的事务传播行为决定的。</p>
<p>![image-20210409151642364](/Users/heqinyang/Library/Application Support/typora-user-images/image-20210409151642364.png)</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p><strong>常见的web负载均衡技术包括：DNS轮询、IP负载均衡和CDN</strong></p>
<h3 id="什么是web负载均衡"><a href="#什么是web负载均衡" class="headerlink" title="什么是web负载均衡"></a>什么是web负载均衡</h3><p>服务器集群(Cluster)使得多个服务器节点能够协同工作，根据目的的不同，服务器集群可以分为：</p>
<ul>
<li>高性能集群：将单个重负载的请求分散到多个节点进行处理，最后再将处理结果进行汇总</li>
<li>高可用集群：提高冗余单元，避免单点故障</li>
<li>负载均衡集群：<strong>将大量的并发请求分担到多个处理节点。由于单个处理节点的故障不影响整个服务，负载均衡集群同时也实现了高可用性。</strong></li>
</ul>
<h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>DNS轮询是最简单的负载均衡方式。以域名作为访问入口，通过配置多条DNS A记录使得请求可以分配到不同的服务器。</p>
<h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>CDN（Content Delivery Network，内容分发网络）。通过发布机制将内容同步到大量的缓存节点，并在DNS服务器上进行扩展，找到里用户最近的缓存节点作为服务提供节点。</p>
<h4 id="反向代理Nginx"><a href="#反向代理Nginx" class="headerlink" title="反向代理Nginx"></a>反向代理Nginx</h4><p>A)轮询(默认):每个请求按时间顺序逐一分配到不同的后端服务器;</p>
<p>B)ip_hash:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</p>
<p>C)url_hash:按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。同一个url（也就是同一个资源请求）会到达同一台机器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取</p>
<p>D)fair:这是比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持 fair的，如果需要使用这种调度算法，必须下载Nginx的 upstream_fair模块。</p>
<h3 id="覆盖索引与回表"><a href="#覆盖索引与回表" class="headerlink" title="覆盖索引与回表"></a>覆盖索引与回表</h3><h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h4><p>要说回表查询，先要从InnoDB的索引实现说起。InnoDB有两大类索引，一类是聚集索引（Clustered Index），一类是普通索引（Secondary Index）</p>
<p><strong>InnoDB的聚集索引</strong></p>
<p>InnoDB聚集索引的叶子节点存储行记录，因此InnoDB必须要有且只有一个聚集索引。</p>
<p>1.如果表定义了PK（Primary Key，主键），那么PK就是聚集索引。</p>
<p>2.如果表没有定义PK，则第一个NOT NULL UNIQUE的列就是聚集索引。</p>
<p>3.否则InnoDB会另外创建一个隐藏的ROWID作为聚集索引。</p>
<p>这种机制使得基于PK的查询速度非常快，因为直接定位的行记录。</p>
<p><strong>InnoDB的普通索引</strong></p>
<p>InnoDB普通索引的叶子节点存储主键值（MyISAM则是存储的行记录头指针）。</p>
<h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>索引覆盖是一种避免回表查询的优化策略。具体的做法就是将要查询的数据作为索引列建立普通索引（可以是单列索引，也可以一个索引语句定义所有要查询的列，即联合索引），这样的话就可以直接返回索引中的的数据，不需要再通过聚集索引去定位行记录，避免了回表的情况发生。</p>
<p>如果一个索引覆盖（包含）了所有需要查询的字段的值，这个索引就是覆盖索引。因为索引中已经包含了要查询的字段的值，因此查询的时候直接返回索引中的字段值就可以了，不需要再到表中查询，避免了对主键索引的二次查询，也就提高了查询的效率。</p>
<h3 id="可重复度下，间隙锁解决幻读"><a href="#可重复度下，间隙锁解决幻读" class="headerlink" title="可重复度下，间隙锁解决幻读"></a>可重复度下，间隙锁解决幻读</h3><h4 id="幻度"><a href="#幻度" class="headerlink" title="幻度"></a>幻度</h4><p>幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。</p>
<p>这里，我需要对 “ 幻读 ” 做一个说明：</p>
<ol>
<li>在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在 “ 当前读 ” 下才会出现。</li>
<li>幻读仅专指 “ 新插入的行 ” 。对同一行数据进行修改，被另一个线程所看到的，不能称为幻读</li>
</ol>
<p>产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的 “ 间隙 ” 。</p>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>为了解决幻读问题， InnoDB 只好引入新的锁，也就是间隙锁 (GapLock) 。<strong>对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”</strong></p>
<p>锁的就是两个值之间的空隙。在一行行扫描的过程中，不仅将给行加上了行锁，还给行两边的空隙，也加上了间隙锁。</p>
<h3 id="当前读，快照读"><a href="#当前读，快照读" class="headerlink" title="当前读，快照读"></a>当前读，快照读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>读取的是记录数据的可见版本（可能是过期的数据），不用加锁。</p>
<p>当执行select *之后，在A与B事务中都会返回4条一样的数据，这是不用想的，当执行select的时候，innodb默认会执行快照读，相当于就是给你目前的状态找了一张照片，以后执行select 的时候就会返回当前照片里面的数据，当其他事务提交了也对你不造成影响，和你没关系，这就实现了可重复读了。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>读取的是记录数据的最新版本，并且当前读返回的记录都会加上锁，保证其他事务不会再并发的修改这条记录</p>
<p>当你执行update、insert、delete 这几个操作的时候默认会执行当前读，也就是会读取最新的记录，也就是别的事务提交的数据你也可以看到</p>

    </div>

    
    
    

      <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
        
      </div>

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/03/10/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F/" rel="prev" title="阿里面经">
      <i class="fa fa-chevron-left"></i> 阿里面经
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/test/" rel="next" title="test">
      test <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面经"><span class="nav-number">1.</span> <span class="nav-text">面经</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Top-K问题"><span class="nav-number">1.1.</span> <span class="nav-text">Top K问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类选择排序"><span class="nav-number">1.1.1.</span> <span class="nav-text">类选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">1.1.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-number">1.1.3.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP1-0和HTTP1-1和HTTP2-0的区别"><span class="nav-number">1.2.</span> <span class="nav-text">HTTP1.0和HTTP1.1和HTTP2.0的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-0和HTTP1-1的区别"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTP1.0和HTTP1.1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP1-1和HTTP2-0的区别"><span class="nav-number">1.2.2.</span> <span class="nav-text">HTTP1.1和HTTP2.0的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的条件-如何避免"><span class="nav-number">1.3.</span> <span class="nav-text">死锁的条件 如何避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#四个必要条件"><span class="nav-number">1.3.1.</span> <span class="nav-text">四个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免与预防"><span class="nav-number">1.3.2.</span> <span class="nav-text">避免与预防</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#避免"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">避免</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#预防"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">预防</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读写锁和互斥锁"><span class="nav-number">1.4.</span> <span class="nav-text">读写锁和互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥锁（ReentrantLock）"><span class="nav-number">1.4.1.</span> <span class="nav-text">互斥锁（ReentrantLock）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读写锁-ReentrantReadWriteLock"><span class="nav-number">1.4.2.</span> <span class="nav-text">读写锁(ReentrantReadWriteLock)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StampedLock"><span class="nav-number">1.5.</span> <span class="nav-text">StampedLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#悲观读与写锁"><span class="nav-number">1.5.1.</span> <span class="nav-text">悲观读与写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#乐观读（无锁）"><span class="nav-number">1.5.2.</span> <span class="nav-text">乐观读（无锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS-Synchronized取代Segment-ReentrantLock"><span class="nav-number">1.5.3.</span> <span class="nav-text">CAS+Synchronized取代Segment+ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁升级"><span class="nav-number">1.5.4.</span> <span class="nav-text">锁升级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized原理："><span class="nav-number">1.5.5.</span> <span class="nav-text">synchronized原理：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#select、poll和epoll"><span class="nav-number">1.6.</span> <span class="nav-text">select、poll和epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">1.6.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">1.6.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">1.6.3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO与NIO？"><span class="nav-number">1.6.4.</span> <span class="nav-text">IO与NIO？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载机制，双亲委派及其打破"><span class="nav-number">1.7.</span> <span class="nav-text">类加载机制，双亲委派及其打破</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候类加载"><span class="nav-number">1.7.1.</span> <span class="nav-text">什么时候类加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类加载过程"><span class="nav-number">1.7.2.</span> <span class="nav-text">类加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派"><span class="nav-number">1.7.3.</span> <span class="nav-text">双亲委派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#打破双亲委派"><span class="nav-number">1.7.4.</span> <span class="nav-text">打破双亲委派</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object类里面的方法"><span class="nav-number">1.8.</span> <span class="nav-text">Object类里面的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现线程的几种方式"><span class="nav-number">1.9.</span> <span class="nav-text">实现线程的几种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无返回值类型的"><span class="nav-number">1.9.1.</span> <span class="nav-text">无返回值类型的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有返回值类型的"><span class="nav-number">1.9.2.</span> <span class="nav-text">有返回值类型的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.10.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型"><span class="nav-number">1.10.1.</span> <span class="nav-text">类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七大参数"><span class="nav-number">1.10.2.</span> <span class="nav-text">七大参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拒绝策略"><span class="nav-number">1.10.3.</span> <span class="nav-text">拒绝策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">1.11.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么情况使用ThreadLocal"><span class="nav-number">1.11.1.</span> <span class="nav-text">什么情况使用ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原理"><span class="nav-number">1.11.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆还是栈？"><span class="nav-number">1.11.3.</span> <span class="nav-text">堆还是栈？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄漏？"><span class="nav-number">1.11.4.</span> <span class="nav-text">内存泄漏？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用弱引用"><span class="nav-number">1.11.5.</span> <span class="nav-text">为什么使用弱引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#key-使用强引用"><span class="nav-number">1.11.5.1.</span> <span class="nav-text">key 使用强引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#key使用弱引用"><span class="nav-number">1.11.5.2.</span> <span class="nav-text">key使用弱引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#myIsam和innodb"><span class="nav-number">1.12.</span> <span class="nav-text">myIsam和innodb</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#innodb引擎的五大特性"><span class="nav-number">1.13.</span> <span class="nav-text">innodb引擎的五大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM内存区域和java内存模型"><span class="nav-number">1.14.</span> <span class="nav-text">JVM内存区域和java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存区域和OOM"><span class="nav-number">1.14.1.</span> <span class="nav-text">内存区域和OOM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM"><span class="nav-number">1.14.2.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#volatile"><span class="nav-number">1.14.2.1.</span> <span class="nav-text">volatile</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#happens-before"><span class="nav-number">1.14.2.2.</span> <span class="nav-text">happens-before</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存失效和缓存穿透解决办法"><span class="nav-number">1.15.</span> <span class="nav-text">缓存失效和缓存穿透解决办法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean加载流程"><span class="nav-number">1.16.</span> <span class="nav-text">Spring Bean加载流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP动态代理"><span class="nav-number">1.17.</span> <span class="nav-text">AOP动态代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK动态代理"><span class="nav-number">1.17.1.</span> <span class="nav-text">JDK动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CGLB动态代理"><span class="nav-number">1.17.2.</span> <span class="nav-text">CGLB动态代理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resource-和-Autowire-注解有什么区别？"><span class="nav-number">1.18.</span> <span class="nav-text">@Resource 和 @Autowire 注解有什么区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Resource"><span class="nav-number">1.18.1.</span> <span class="nav-text">@Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Autowire"><span class="nav-number">1.18.2.</span> <span class="nav-text">@Autowire</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BeanFactory-和-ApplicationContext-有什么区别？"><span class="nav-number">1.19.</span> <span class="nav-text">BeanFactory 和 ApplicationContext 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET-POST"><span class="nav-number">1.20.</span> <span class="nav-text">GET POST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC"><span class="nav-number">1.21.</span> <span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo"><span class="nav-number">1.22.</span> <span class="nav-text">Dubbo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NoSQL"><span class="nav-number">1.23.</span> <span class="nav-text">NoSQL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAP"><span class="nav-number">1.23.1.</span> <span class="nav-text">CAP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BASE"><span class="nav-number">1.23.2.</span> <span class="nav-text">BASE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-七种事务传播属性和五种隔离级别"><span class="nav-number">1.24.</span> <span class="nav-text">Spring 七种事务传播属性和五种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传播行为"><span class="nav-number">1.24.1.</span> <span class="nav-text">传播行为</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡"><span class="nav-number">1.25.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是web负载均衡"><span class="nav-number">1.26.</span> <span class="nav-text">什么是web负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS"><span class="nav-number">1.26.1.</span> <span class="nav-text">DNS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CDN"><span class="nav-number">1.26.2.</span> <span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反向代理Nginx"><span class="nav-number">1.26.3.</span> <span class="nav-text">反向代理Nginx</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#覆盖索引与回表"><span class="nav-number">1.27.</span> <span class="nav-text">覆盖索引与回表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#回表查询"><span class="nav-number">1.27.1.</span> <span class="nav-text">回表查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引覆盖"><span class="nav-number">1.27.2.</span> <span class="nav-text">索引覆盖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可重复度下，间隙锁解决幻读"><span class="nav-number">1.28.</span> <span class="nav-text">可重复度下，间隙锁解决幻读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#幻度"><span class="nav-number">1.28.1.</span> <span class="nav-text">幻度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#间隙锁"><span class="nav-number">1.28.2.</span> <span class="nav-text">间隙锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#当前读，快照读"><span class="nav-number">1.29.</span> <span class="nav-text">当前读，快照读</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#快照读"><span class="nav-number">1.29.1.</span> <span class="nav-text">快照读</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#当前读"><span class="nav-number">1.29.2.</span> <span class="nav-text">当前读</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">curryhqy</p>
  <div class="site-description" itemprop="description">现在我混日子，将来日子混我</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">curryhqy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>
